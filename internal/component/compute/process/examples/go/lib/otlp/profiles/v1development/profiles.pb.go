// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.8.0
// source: opentelemetry/proto/profiles/v1development/profiles.proto

package opentelemetry_proto_profiles_v1development

import (
	fmt "fmt"
	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	v11 "github.com/grafana/alloy/internal/component/compute/process/examples/go/lib/otlp/common/v1"
	v1 "github.com/grafana/alloy/internal/component/compute/process/examples/go/lib/otlp/resource/v1"
	io "io"
	strconv "strconv"
)

// Copyright 2023, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file includes work covered by the following copyright and permission notices:
//
// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Specifies the method of aggregating metric values, either DELTA (change since last report)
// or CUMULATIVE (total since a fixed start time).
type AggregationTemporality int32

const (
	// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
	AggregationTemporality_AGGREGATION_TEMPORALITY_UNSPECIFIED AggregationTemporality = 0
	// * DELTA is an AggregationTemporality for a profiler which reports
	// changes since last report time. Successive metrics contain aggregation of
	// values from continuous and non-overlapping intervals.
	//
	// The values for a DELTA metric are based only on the time interval
	// associated with one measurement cycle. There is no dependency on
	// previous measurements like is the case for CUMULATIVE metrics.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// DELTA metric:
	//
	// 1. The system starts receiving at time=t_0.
	// 2. A request is received, the system measures 1 request.
	// 3. A request is received, the system measures 1 request.
	// 4. A request is received, the system measures 1 request.
	// 5. The 1 second collection cycle ends. A metric is exported for the
	// number of requests received over the interval of time t_0 to
	// t_0+1 with a value of 3.
	// 6. A request is received, the system measures 1 request.
	// 7. A request is received, the system measures 1 request.
	// 8. The 1 second collection cycle ends. A metric is exported for the
	// number of requests received over the interval of time t_0+1 to
	// t_0+2 with a value of 2.
	AggregationTemporality_AGGREGATION_TEMPORALITY_DELTA AggregationTemporality = 1
	// * CUMULATIVE is an AggregationTemporality for a profiler which
	// reports changes since a fixed start time. This means that current values
	// of a CUMULATIVE metric depend on all previous measurements since the
	// start time. Because of this, the sender is required to retain this state
	// in some form. If this state is lost or invalidated, the CUMULATIVE metric
	// values MUST be reset and a new fixed start time following the last
	// reported measurement time sent MUST be used.
	//
	// For example, consider a system measuring the number of requests that
	// it receives and reports the sum of these requests every second as a
	// CUMULATIVE metric:
	//
	// 1. The system starts receiving at time=t_0.
	// 2. A request is received, the system measures 1 request.
	// 3. A request is received, the system measures 1 request.
	// 4. A request is received, the system measures 1 request.
	// 5. The 1 second collection cycle ends. A metric is exported for the
	// number of requests received over the interval of time t_0 to
	// t_0+1 with a value of 3.
	// 6. A request is received, the system measures 1 request.
	// 7. A request is received, the system measures 1 request.
	// 8. The 1 second collection cycle ends. A metric is exported for the
	// number of requests received over the interval of time t_0 to
	// t_0+2 with a value of 5.
	// 9. The system experiences a fault and loses state.
	// 10. The system recovers and resumes receiving at time=t_1.
	// 11. A request is received, the system measures 1 request.
	// 12. The 1 second collection cycle ends. A metric is exported for the
	// number of requests received over the interval of time t_1 to
	// t_1+1 with a value of 1.
	//
	// Note: Even though, when reporting changes since last report time, using
	// CUMULATIVE is valid, it is not recommended.
	AggregationTemporality_AGGREGATION_TEMPORALITY_CUMULATIVE AggregationTemporality = 2
)

// Enum value maps for AggregationTemporality.
var (
	AggregationTemporality_name = map[int32]string{
		0: "AGGREGATION_TEMPORALITY_UNSPECIFIED",
		1: "AGGREGATION_TEMPORALITY_DELTA",
		2: "AGGREGATION_TEMPORALITY_CUMULATIVE",
	}
	AggregationTemporality_value = map[string]int32{
		"AGGREGATION_TEMPORALITY_UNSPECIFIED": 0,
		"AGGREGATION_TEMPORALITY_DELTA":       1,
		"AGGREGATION_TEMPORALITY_CUMULATIVE":  2,
	}
)

func (x AggregationTemporality) Enum() *AggregationTemporality {
	p := new(AggregationTemporality)
	*p = x
	return p
}

func (x AggregationTemporality) String() string {
	name, valid := AggregationTemporality_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

// ProfilesData represents the profiles data that can be stored in persistent storage,
// OR can be embedded by other protocols that transfer OTLP profiles data but do not
// implement the OTLP protocol.
//
// The main difference between this message and collector protocol is that
// in this message there will not be any "control" or "metadata" specific to
// OTLP protocol.
//
// When new fields are added into this message, the OTLP request MUST be updated
// as well.
type ProfilesData struct {
	unknownFields []byte
	// An array of ResourceProfiles.
	// For data coming from a single resource this array will typically contain
	// one element. Intermediary nodes that receive data from multiple origins
	// typically batch the data before forwarding further and in that case this
	// array will contain multiple elements.
	ResourceProfiles []*ResourceProfiles `protobuf:"bytes,1,rep,name=resource_profiles,json=resourceProfiles,proto3" json:"resourceProfiles,omitempty"`
}

func (x *ProfilesData) Reset() {
	*x = ProfilesData{}
}

func (*ProfilesData) ProtoMessage() {}

func (x *ProfilesData) GetResourceProfiles() []*ResourceProfiles {
	if x != nil {
		return x.ResourceProfiles
	}
	return nil
}

// A collection of ScopeProfiles from a Resource.
type ResourceProfiles struct {
	unknownFields []byte
	// The resource for the profiles in this message.
	// If this field is not set then no resource info is known.
	Resource *v1.Resource `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// A list of ScopeProfiles that originate from a resource.
	ScopeProfiles []*ScopeProfiles `protobuf:"bytes,2,rep,name=scope_profiles,json=scopeProfiles,proto3" json:"scopeProfiles,omitempty"`
	// The Schema URL, if known. This is the identifier of the Schema that the resource data
	// is recorded in. To learn more about Schema URL see
	// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
	// This schema_url applies to the data in the "resource" field. It does not apply
	// to the data in the "scope_profiles" field which have their own schema_url field.
	SchemaUrl string `protobuf:"bytes,3,opt,name=schema_url,json=schemaUrl,proto3" json:"schemaUrl,omitempty"`
}

func (x *ResourceProfiles) Reset() {
	*x = ResourceProfiles{}
}

func (*ResourceProfiles) ProtoMessage() {}

func (x *ResourceProfiles) GetResource() *v1.Resource {
	if x != nil {
		return x.Resource
	}
	return nil
}

func (x *ResourceProfiles) GetScopeProfiles() []*ScopeProfiles {
	if x != nil {
		return x.ScopeProfiles
	}
	return nil
}

func (x *ResourceProfiles) GetSchemaUrl() string {
	if x != nil {
		return x.SchemaUrl
	}
	return ""
}

// A collection of Profiles produced by an InstrumentationScope.
type ScopeProfiles struct {
	unknownFields []byte
	// The instrumentation scope information for the profiles in this message.
	// Semantically when InstrumentationScope isn't set, it is equivalent with
	// an empty instrumentation scope name (unknown).
	Scope *v11.InstrumentationScope `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	// A list of Profiles that originate from an instrumentation scope.
	Profiles []*Profile `protobuf:"bytes,2,rep,name=profiles,proto3" json:"profiles,omitempty"`
	// The Schema URL, if known. This is the identifier of the Schema that the profile data
	// is recorded in. To learn more about Schema URL see
	// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
	// This schema_url applies to all profiles in the "profiles" field.
	SchemaUrl string `protobuf:"bytes,3,opt,name=schema_url,json=schemaUrl,proto3" json:"schemaUrl,omitempty"`
}

func (x *ScopeProfiles) Reset() {
	*x = ScopeProfiles{}
}

func (*ScopeProfiles) ProtoMessage() {}

func (x *ScopeProfiles) GetScope() *v11.InstrumentationScope {
	if x != nil {
		return x.Scope
	}
	return nil
}

func (x *ScopeProfiles) GetProfiles() []*Profile {
	if x != nil {
		return x.Profiles
	}
	return nil
}

func (x *ScopeProfiles) GetSchemaUrl() string {
	if x != nil {
		return x.SchemaUrl
	}
	return ""
}

// Represents a complete profile, including sample types, samples,
// mappings to binaries, locations, functions, string table, and additional metadata.
// It modifies and annotates pprof Profile with OpenTelemetry specific fields.
//
// Note that whilst fields in this message retain the name and field id from pprof in most cases
// for ease of understanding data migration, it is not intended that pprof:Profile and
// OpenTelemetry:Profile encoding be wire compatible.
type Profile struct {
	unknownFields []byte
	// A description of the samples associated with each Sample.value.
	// For a cpu profile this might be:
	//
	//	[["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
	//
	// For a heap profile, this might be:
	//
	//	[["allocations","count"], ["space","bytes"]],
	//
	// If one of the values represents the number of events represented
	// by the sample, by convention it should be at index 0 and use
	// sample_type.unit == "count".
	SampleType []*ValueType `protobuf:"bytes,1,rep,name=sample_type,json=sampleType,proto3" json:"sampleType,omitempty"`
	// The set of samples recorded in this profile.
	Sample []*Sample `protobuf:"bytes,2,rep,name=sample,proto3" json:"sample,omitempty"`
	// Mapping from address ranges to the image/binary/library mapped
	// into that address range.  mapping[0] will be the main binary.
	// If multiple binaries contribute to the Profile and no main
	// binary can be identified, mapping[0] has no special meaning.
	MappingTable []*Mapping `protobuf:"bytes,3,rep,name=mapping_table,json=mappingTable,proto3" json:"mappingTable,omitempty"`
	// Locations referenced by samples via location_indices.
	LocationTable []*Location `protobuf:"bytes,4,rep,name=location_table,json=locationTable,proto3" json:"locationTable,omitempty"`
	// Array of locations referenced by samples.
	LocationIndices []int32 `protobuf:"varint,5,rep,packed,name=location_indices,json=locationIndices,proto3" json:"locationIndices,omitempty"`
	// Functions referenced by locations.
	FunctionTable []*Function `protobuf:"bytes,6,rep,name=function_table,json=functionTable,proto3" json:"functionTable,omitempty"`
	// Lookup table for attributes.
	AttributeTable []*v11.KeyValue `protobuf:"bytes,7,rep,name=attribute_table,json=attributeTable,proto3" json:"attributeTable,omitempty"`
	// Represents a mapping between Attribute Keys and Units.
	AttributeUnits []*AttributeUnit `protobuf:"bytes,8,rep,name=attribute_units,json=attributeUnits,proto3" json:"attributeUnits,omitempty"`
	// Lookup table for links.
	LinkTable []*Link `protobuf:"bytes,9,rep,name=link_table,json=linkTable,proto3" json:"linkTable,omitempty"`
	// A common table for strings referenced by various messages.
	// string_table[0] must always be "".
	StringTable []string `protobuf:"bytes,10,rep,name=string_table,json=stringTable,proto3" json:"stringTable,omitempty"`
	// Time of collection (UTC) represented as nanoseconds past the epoch.
	TimeNanos int64 `protobuf:"varint,11,opt,name=time_nanos,json=timeNanos,proto3" json:"timeNanos,omitempty"`
	// Duration of the profile, if a duration makes sense.
	DurationNanos int64 `protobuf:"varint,12,opt,name=duration_nanos,json=durationNanos,proto3" json:"durationNanos,omitempty"`
	// The kind of events between sampled occurrences.
	// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
	PeriodType *ValueType `protobuf:"bytes,13,opt,name=period_type,json=periodType,proto3" json:"periodType,omitempty"`
	// The number of events between sampled occurrences.
	Period int64 `protobuf:"varint,14,opt,name=period,proto3" json:"period,omitempty"`
	// Free-form text associated with the profile. The text is displayed as is
	// to the user by the tools that read profiles (e.g. by pprof). This field
	// should not be used to store any machine-readable information, it is only
	// for human-friendly content. The profile must stay functional if this field
	// is cleaned.
	CommentStrindices []int32 `protobuf:"varint,15,rep,packed,name=comment_strindices,json=commentStrindices,proto3" json:"commentStrindices,omitempty"` // Indices into string table.
	// Index into the string table of the type of the preferred sample
	// value. If unset, clients should default to the last sample value.
	DefaultSampleTypeStrindex int32 `protobuf:"varint,16,opt,name=default_sample_type_strindex,json=defaultSampleTypeStrindex,proto3" json:"defaultSampleTypeStrindex,omitempty"`
	// A globally unique identifier for a profile. The ID is a 16-byte array. An ID with
	// all zeroes is considered invalid.
	//
	// This field is required.
	ProfileId []byte `protobuf:"bytes,17,opt,name=profile_id,json=profileId,proto3" json:"profileId,omitempty"`
	// attributes is a collection of key/value pairs. Note, global attributes
	// like server name can be set using the resource API. Examples of attributes:
	//
	//	"/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
	//	"/http/server_latency": 300
	//	"abc.com/myattribute": true
	//	"abc.com/score": 10.239
	//
	// The OpenTelemetry API specification further restricts the allowed value types:
	// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes []*v11.KeyValue `protobuf:"bytes,18,rep,name=attributes,proto3" json:"attributes,omitempty"`
	// dropped_attributes_count is the number of attributes that were discarded. Attributes
	// can be discarded because their keys are too long or because there are too many
	// attributes. If this value is 0, then no attributes were dropped.
	DroppedAttributesCount uint32 `protobuf:"varint,19,opt,name=dropped_attributes_count,json=droppedAttributesCount,proto3" json:"droppedAttributesCount,omitempty"`
	// Specifies format of the original payload. Common values are defined in semantic conventions. [required if original_payload is present]
	OriginalPayloadFormat string `protobuf:"bytes,20,opt,name=original_payload_format,json=originalPayloadFormat,proto3" json:"originalPayloadFormat,omitempty"`
	// Original payload can be stored in this field. This can be useful for users who want to get the original payload.
	// Formats such as JFR are highly extensible and can contain more information than what is defined in this spec.
	// Inclusion of original payload should be configurable by the user. Default behavior should be to not include the original payload.
	// If the original payload is in pprof format, it SHOULD not be included in this field.
	// The field is optional, however if it is present then equivalent converted data should be populated in other fields
	// of this message as far as is practicable.
	OriginalPayload []byte `protobuf:"bytes,21,opt,name=original_payload,json=originalPayload,proto3" json:"originalPayload,omitempty"`
}

func (x *Profile) Reset() {
	*x = Profile{}
}

func (*Profile) ProtoMessage() {}

func (x *Profile) GetSampleType() []*ValueType {
	if x != nil {
		return x.SampleType
	}
	return nil
}

func (x *Profile) GetSample() []*Sample {
	if x != nil {
		return x.Sample
	}
	return nil
}

func (x *Profile) GetMappingTable() []*Mapping {
	if x != nil {
		return x.MappingTable
	}
	return nil
}

func (x *Profile) GetLocationTable() []*Location {
	if x != nil {
		return x.LocationTable
	}
	return nil
}

func (x *Profile) GetLocationIndices() []int32 {
	if x != nil {
		return x.LocationIndices
	}
	return nil
}

func (x *Profile) GetFunctionTable() []*Function {
	if x != nil {
		return x.FunctionTable
	}
	return nil
}

func (x *Profile) GetAttributeTable() []*v11.KeyValue {
	if x != nil {
		return x.AttributeTable
	}
	return nil
}

func (x *Profile) GetAttributeUnits() []*AttributeUnit {
	if x != nil {
		return x.AttributeUnits
	}
	return nil
}

func (x *Profile) GetLinkTable() []*Link {
	if x != nil {
		return x.LinkTable
	}
	return nil
}

func (x *Profile) GetStringTable() []string {
	if x != nil {
		return x.StringTable
	}
	return nil
}

func (x *Profile) GetTimeNanos() int64 {
	if x != nil {
		return x.TimeNanos
	}
	return 0
}

func (x *Profile) GetDurationNanos() int64 {
	if x != nil {
		return x.DurationNanos
	}
	return 0
}

func (x *Profile) GetPeriodType() *ValueType {
	if x != nil {
		return x.PeriodType
	}
	return nil
}

func (x *Profile) GetPeriod() int64 {
	if x != nil {
		return x.Period
	}
	return 0
}

func (x *Profile) GetCommentStrindices() []int32 {
	if x != nil {
		return x.CommentStrindices
	}
	return nil
}

func (x *Profile) GetDefaultSampleTypeStrindex() int32 {
	if x != nil {
		return x.DefaultSampleTypeStrindex
	}
	return 0
}

func (x *Profile) GetProfileId() []byte {
	if x != nil {
		return x.ProfileId
	}
	return nil
}

func (x *Profile) GetAttributes() []*v11.KeyValue {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *Profile) GetDroppedAttributesCount() uint32 {
	if x != nil {
		return x.DroppedAttributesCount
	}
	return 0
}

func (x *Profile) GetOriginalPayloadFormat() string {
	if x != nil {
		return x.OriginalPayloadFormat
	}
	return ""
}

func (x *Profile) GetOriginalPayload() []byte {
	if x != nil {
		return x.OriginalPayload
	}
	return nil
}

// Represents a mapping between Attribute Keys and Units.
type AttributeUnit struct {
	unknownFields []byte
	// Index into string table.
	AttributeKeyStrindex int32 `protobuf:"varint,1,opt,name=attribute_key_strindex,json=attributeKeyStrindex,proto3" json:"attributeKeyStrindex,omitempty"`
	// Index into string table.
	UnitStrindex int32 `protobuf:"varint,2,opt,name=unit_strindex,json=unitStrindex,proto3" json:"unitStrindex,omitempty"`
}

func (x *AttributeUnit) Reset() {
	*x = AttributeUnit{}
}

func (*AttributeUnit) ProtoMessage() {}

func (x *AttributeUnit) GetAttributeKeyStrindex() int32 {
	if x != nil {
		return x.AttributeKeyStrindex
	}
	return 0
}

func (x *AttributeUnit) GetUnitStrindex() int32 {
	if x != nil {
		return x.UnitStrindex
	}
	return 0
}

// A pointer from a profile Sample to a trace Span.
// Connects a profile sample to a trace span, identified by unique trace and span IDs.
type Link struct {
	unknownFields []byte
	// A unique identifier of a trace that this linked span is part of. The ID is a
	// 16-byte array.
	TraceId []byte `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3" json:"traceId,omitempty"`
	// A unique identifier for the linked span. The ID is an 8-byte array.
	SpanId []byte `protobuf:"bytes,2,opt,name=span_id,json=spanId,proto3" json:"spanId,omitempty"`
}

func (x *Link) Reset() {
	*x = Link{}
}

func (*Link) ProtoMessage() {}

func (x *Link) GetTraceId() []byte {
	if x != nil {
		return x.TraceId
	}
	return nil
}

func (x *Link) GetSpanId() []byte {
	if x != nil {
		return x.SpanId
	}
	return nil
}

// ValueType describes the type and units of a value, with an optional aggregation temporality.
type ValueType struct {
	unknownFields          []byte
	TypeStrindex           int32                  `protobuf:"varint,1,opt,name=type_strindex,json=typeStrindex,proto3" json:"typeStrindex,omitempty"` // Index into string table.
	UnitStrindex           int32                  `protobuf:"varint,2,opt,name=unit_strindex,json=unitStrindex,proto3" json:"unitStrindex,omitempty"` // Index into string table.
	AggregationTemporality AggregationTemporality `protobuf:"varint,3,opt,name=aggregation_temporality,json=aggregationTemporality,proto3" json:"aggregationTemporality,omitempty"`
}

func (x *ValueType) Reset() {
	*x = ValueType{}
}

func (*ValueType) ProtoMessage() {}

func (x *ValueType) GetTypeStrindex() int32 {
	if x != nil {
		return x.TypeStrindex
	}
	return 0
}

func (x *ValueType) GetUnitStrindex() int32 {
	if x != nil {
		return x.UnitStrindex
	}
	return 0
}

func (x *ValueType) GetAggregationTemporality() AggregationTemporality {
	if x != nil {
		return x.AggregationTemporality
	}
	return AggregationTemporality_AGGREGATION_TEMPORALITY_UNSPECIFIED
}

// Each Sample records values encountered in some program
// context. The program context is typically a stack trace, perhaps
// augmented with auxiliary information like the thread-id, some
// indicator of a higher level request being handled etc.
type Sample struct {
	unknownFields []byte
	// locations_start_index along with locations_length refers to to a slice of locations in Profile.location_indices.
	LocationsStartIndex int32 `protobuf:"varint,1,opt,name=locations_start_index,json=locationsStartIndex,proto3" json:"locationsStartIndex,omitempty"`
	// locations_length along with locations_start_index refers to a slice of locations in Profile.location_indices.
	// Supersedes location_index.
	LocationsLength int32 `protobuf:"varint,2,opt,name=locations_length,json=locationsLength,proto3" json:"locationsLength,omitempty"`
	// The type and unit of each value is defined by the corresponding
	// entry in Profile.sample_type. All samples must have the same
	// number of values, the same as the length of Profile.sample_type.
	// When aggregating multiple samples into a single sample, the
	// result has a list of values that is the element-wise sum of the
	// lists of the originals.
	Value []int64 `protobuf:"varint,3,rep,packed,name=value,proto3" json:"value,omitempty"`
	// References to attributes in Profile.attribute_table. [optional]
	AttributeIndices []int32 `protobuf:"varint,4,rep,packed,name=attribute_indices,json=attributeIndices,proto3" json:"attributeIndices,omitempty"`
	// Reference to link in Profile.link_table. [optional]
	LinkIndex *int32 `protobuf:"varint,5,opt,name=link_index,json=linkIndex,proto3,oneof" json:"linkIndex,omitempty"`
	// Timestamps associated with Sample represented in nanoseconds. These timestamps are expected
	// to fall within the Profile's time range. [optional]
	TimestampsUnixNano []uint64 `protobuf:"varint,6,rep,packed,name=timestamps_unix_nano,json=timestampsUnixNano,proto3" json:"timestampsUnixNano,omitempty"`
}

func (x *Sample) Reset() {
	*x = Sample{}
}

func (*Sample) ProtoMessage() {}

func (x *Sample) GetLocationsStartIndex() int32 {
	if x != nil {
		return x.LocationsStartIndex
	}
	return 0
}

func (x *Sample) GetLocationsLength() int32 {
	if x != nil {
		return x.LocationsLength
	}
	return 0
}

func (x *Sample) GetValue() []int64 {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Sample) GetAttributeIndices() []int32 {
	if x != nil {
		return x.AttributeIndices
	}
	return nil
}

func (x *Sample) GetLinkIndex() int32 {
	if x != nil && x.LinkIndex != nil {
		return *x.LinkIndex
	}
	return 0
}

func (x *Sample) GetTimestampsUnixNano() []uint64 {
	if x != nil {
		return x.TimestampsUnixNano
	}
	return nil
}

// Describes the mapping of a binary in memory, including its address range,
// file offset, and metadata like build ID
type Mapping struct {
	unknownFields []byte
	// Address at which the binary (or DLL) is loaded into memory.
	MemoryStart uint64 `protobuf:"varint,1,opt,name=memory_start,json=memoryStart,proto3" json:"memoryStart,omitempty"`
	// The limit of the address range occupied by this mapping.
	MemoryLimit uint64 `protobuf:"varint,2,opt,name=memory_limit,json=memoryLimit,proto3" json:"memoryLimit,omitempty"`
	// Offset in the binary that corresponds to the first mapped address.
	FileOffset uint64 `protobuf:"varint,3,opt,name=file_offset,json=fileOffset,proto3" json:"fileOffset,omitempty"`
	// The object this entry is loaded from.  This can be a filename on
	// disk for the main binary and shared libraries, or virtual
	// abstractions like "[vdso]".
	FilenameStrindex int32 `protobuf:"varint,4,opt,name=filename_strindex,json=filenameStrindex,proto3" json:"filenameStrindex,omitempty"` // Index into string table
	// References to attributes in Profile.attribute_table. [optional]
	AttributeIndices []int32 `protobuf:"varint,5,rep,packed,name=attribute_indices,json=attributeIndices,proto3" json:"attributeIndices,omitempty"`
	// The following fields indicate the resolution of symbolic info.
	HasFunctions    bool `protobuf:"varint,6,opt,name=has_functions,json=hasFunctions,proto3" json:"hasFunctions,omitempty"`
	HasFilenames    bool `protobuf:"varint,7,opt,name=has_filenames,json=hasFilenames,proto3" json:"hasFilenames,omitempty"`
	HasLineNumbers  bool `protobuf:"varint,8,opt,name=has_line_numbers,json=hasLineNumbers,proto3" json:"hasLineNumbers,omitempty"`
	HasInlineFrames bool `protobuf:"varint,9,opt,name=has_inline_frames,json=hasInlineFrames,proto3" json:"hasInlineFrames,omitempty"`
}

func (x *Mapping) Reset() {
	*x = Mapping{}
}

func (*Mapping) ProtoMessage() {}

func (x *Mapping) GetMemoryStart() uint64 {
	if x != nil {
		return x.MemoryStart
	}
	return 0
}

func (x *Mapping) GetMemoryLimit() uint64 {
	if x != nil {
		return x.MemoryLimit
	}
	return 0
}

func (x *Mapping) GetFileOffset() uint64 {
	if x != nil {
		return x.FileOffset
	}
	return 0
}

func (x *Mapping) GetFilenameStrindex() int32 {
	if x != nil {
		return x.FilenameStrindex
	}
	return 0
}

func (x *Mapping) GetAttributeIndices() []int32 {
	if x != nil {
		return x.AttributeIndices
	}
	return nil
}

func (x *Mapping) GetHasFunctions() bool {
	if x != nil {
		return x.HasFunctions
	}
	return false
}

func (x *Mapping) GetHasFilenames() bool {
	if x != nil {
		return x.HasFilenames
	}
	return false
}

func (x *Mapping) GetHasLineNumbers() bool {
	if x != nil {
		return x.HasLineNumbers
	}
	return false
}

func (x *Mapping) GetHasInlineFrames() bool {
	if x != nil {
		return x.HasInlineFrames
	}
	return false
}

// Describes function and line table debug information.
type Location struct {
	unknownFields []byte
	// Reference to mapping in Profile.mapping_table.
	// It can be unset if the mapping is unknown or not applicable for
	// this profile type.
	MappingIndex *int32 `protobuf:"varint,1,opt,name=mapping_index,json=mappingIndex,proto3,oneof" json:"mappingIndex,omitempty"`
	// The instruction address for this location, if available.  It
	// should be within [Mapping.memory_start...Mapping.memory_limit]
	// for the corresponding mapping. A non-leaf address may be in the
	// middle of a call instruction. It is up to display tools to find
	// the beginning of the instruction if necessary.
	Address uint64 `protobuf:"varint,2,opt,name=address,proto3" json:"address,omitempty"`
	// Multiple line indicates this location has inlined functions,
	// where the last entry represents the caller into which the
	// preceding entries were inlined.
	//
	// E.g., if memcpy() is inlined into printf:
	//
	//	line[0].function_name == "memcpy"
	//	line[1].function_name == "printf"
	Line []*Line `protobuf:"bytes,3,rep,name=line,proto3" json:"line,omitempty"`
	// Provides an indication that multiple symbols map to this location's
	// address, for example due to identical code folding by the linker. In that
	// case the line information above represents one of the multiple
	// symbols. This field must be recomputed when the symbolization state of the
	// profile changes.
	IsFolded bool `protobuf:"varint,4,opt,name=is_folded,json=isFolded,proto3" json:"isFolded,omitempty"`
	// References to attributes in Profile.attribute_table. [optional]
	AttributeIndices []int32 `protobuf:"varint,5,rep,packed,name=attribute_indices,json=attributeIndices,proto3" json:"attributeIndices,omitempty"`
}

func (x *Location) Reset() {
	*x = Location{}
}

func (*Location) ProtoMessage() {}

func (x *Location) GetMappingIndex() int32 {
	if x != nil && x.MappingIndex != nil {
		return *x.MappingIndex
	}
	return 0
}

func (x *Location) GetAddress() uint64 {
	if x != nil {
		return x.Address
	}
	return 0
}

func (x *Location) GetLine() []*Line {
	if x != nil {
		return x.Line
	}
	return nil
}

func (x *Location) GetIsFolded() bool {
	if x != nil {
		return x.IsFolded
	}
	return false
}

func (x *Location) GetAttributeIndices() []int32 {
	if x != nil {
		return x.AttributeIndices
	}
	return nil
}

// Details a specific line in a source code, linked to a function.
type Line struct {
	unknownFields []byte
	// Reference to function in Profile.function_table.
	FunctionIndex int32 `protobuf:"varint,1,opt,name=function_index,json=functionIndex,proto3" json:"functionIndex,omitempty"`
	// Line number in source code.
	Line int64 `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
	// Column number in source code.
	Column int64 `protobuf:"varint,3,opt,name=column,proto3" json:"column,omitempty"`
}

func (x *Line) Reset() {
	*x = Line{}
}

func (*Line) ProtoMessage() {}

func (x *Line) GetFunctionIndex() int32 {
	if x != nil {
		return x.FunctionIndex
	}
	return 0
}

func (x *Line) GetLine() int64 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *Line) GetColumn() int64 {
	if x != nil {
		return x.Column
	}
	return 0
}

// Describes a function, including its human-readable name, system name,
// source file, and starting line number in the source.
type Function struct {
	unknownFields []byte
	// Name of the function, in human-readable form if available.
	NameStrindex int32 `protobuf:"varint,1,opt,name=name_strindex,json=nameStrindex,proto3" json:"nameStrindex,omitempty"` // Index into string table
	// Name of the function, as identified by the system.
	// For instance, it can be a C++ mangled name.
	SystemNameStrindex int32 `protobuf:"varint,2,opt,name=system_name_strindex,json=systemNameStrindex,proto3" json:"systemNameStrindex,omitempty"` // Index into string table
	// Source file containing the function.
	FilenameStrindex int32 `protobuf:"varint,3,opt,name=filename_strindex,json=filenameStrindex,proto3" json:"filenameStrindex,omitempty"` // Index into string table
	// Line number in source file.
	StartLine int64 `protobuf:"varint,4,opt,name=start_line,json=startLine,proto3" json:"startLine,omitempty"`
}

func (x *Function) Reset() {
	*x = Function{}
}

func (*Function) ProtoMessage() {}

func (x *Function) GetNameStrindex() int32 {
	if x != nil {
		return x.NameStrindex
	}
	return 0
}

func (x *Function) GetSystemNameStrindex() int32 {
	if x != nil {
		return x.SystemNameStrindex
	}
	return 0
}

func (x *Function) GetFilenameStrindex() int32 {
	if x != nil {
		return x.FilenameStrindex
	}
	return 0
}

func (x *Function) GetStartLine() int64 {
	if x != nil {
		return x.StartLine
	}
	return 0
}

func (m *ProfilesData) CloneVT() *ProfilesData {
	if m == nil {
		return (*ProfilesData)(nil)
	}
	r := new(ProfilesData)
	if rhs := m.ResourceProfiles; rhs != nil {
		tmpContainer := make([]*ResourceProfiles, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ResourceProfiles = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ProfilesData) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ResourceProfiles) CloneVT() *ResourceProfiles {
	if m == nil {
		return (*ResourceProfiles)(nil)
	}
	r := new(ResourceProfiles)
	r.SchemaUrl = m.SchemaUrl
	if rhs := m.Resource; rhs != nil {
		r.Resource = rhs.CloneVT()
	}
	if rhs := m.ScopeProfiles; rhs != nil {
		tmpContainer := make([]*ScopeProfiles, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.ScopeProfiles = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ResourceProfiles) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ScopeProfiles) CloneVT() *ScopeProfiles {
	if m == nil {
		return (*ScopeProfiles)(nil)
	}
	r := new(ScopeProfiles)
	r.SchemaUrl = m.SchemaUrl
	if rhs := m.Scope; rhs != nil {
		r.Scope = rhs.CloneVT()
	}
	if rhs := m.Profiles; rhs != nil {
		tmpContainer := make([]*Profile, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Profiles = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ScopeProfiles) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Profile) CloneVT() *Profile {
	if m == nil {
		return (*Profile)(nil)
	}
	r := new(Profile)
	r.TimeNanos = m.TimeNanos
	r.DurationNanos = m.DurationNanos
	r.PeriodType = m.PeriodType.CloneVT()
	r.Period = m.Period
	r.DefaultSampleTypeStrindex = m.DefaultSampleTypeStrindex
	r.DroppedAttributesCount = m.DroppedAttributesCount
	r.OriginalPayloadFormat = m.OriginalPayloadFormat
	if rhs := m.SampleType; rhs != nil {
		tmpContainer := make([]*ValueType, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.SampleType = tmpContainer
	}
	if rhs := m.Sample; rhs != nil {
		tmpContainer := make([]*Sample, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Sample = tmpContainer
	}
	if rhs := m.MappingTable; rhs != nil {
		tmpContainer := make([]*Mapping, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.MappingTable = tmpContainer
	}
	if rhs := m.LocationTable; rhs != nil {
		tmpContainer := make([]*Location, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.LocationTable = tmpContainer
	}
	if rhs := m.LocationIndices; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.LocationIndices = tmpContainer
	}
	if rhs := m.FunctionTable; rhs != nil {
		tmpContainer := make([]*Function, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.FunctionTable = tmpContainer
	}
	if rhs := m.AttributeTable; rhs != nil {
		tmpContainer := make([]*v11.KeyValue, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.AttributeTable = tmpContainer
	}
	if rhs := m.AttributeUnits; rhs != nil {
		tmpContainer := make([]*AttributeUnit, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.AttributeUnits = tmpContainer
	}
	if rhs := m.LinkTable; rhs != nil {
		tmpContainer := make([]*Link, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.LinkTable = tmpContainer
	}
	if rhs := m.StringTable; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.StringTable = tmpContainer
	}
	if rhs := m.CommentStrindices; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.CommentStrindices = tmpContainer
	}
	if rhs := m.ProfileId; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.ProfileId = tmpBytes
	}
	if rhs := m.Attributes; rhs != nil {
		tmpContainer := make([]*v11.KeyValue, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Attributes = tmpContainer
	}
	if rhs := m.OriginalPayload; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.OriginalPayload = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Profile) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *AttributeUnit) CloneVT() *AttributeUnit {
	if m == nil {
		return (*AttributeUnit)(nil)
	}
	r := new(AttributeUnit)
	r.AttributeKeyStrindex = m.AttributeKeyStrindex
	r.UnitStrindex = m.UnitStrindex
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *AttributeUnit) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Link) CloneVT() *Link {
	if m == nil {
		return (*Link)(nil)
	}
	r := new(Link)
	if rhs := m.TraceId; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.TraceId = tmpBytes
	}
	if rhs := m.SpanId; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.SpanId = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Link) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *ValueType) CloneVT() *ValueType {
	if m == nil {
		return (*ValueType)(nil)
	}
	r := new(ValueType)
	r.TypeStrindex = m.TypeStrindex
	r.UnitStrindex = m.UnitStrindex
	r.AggregationTemporality = m.AggregationTemporality
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *ValueType) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Sample) CloneVT() *Sample {
	if m == nil {
		return (*Sample)(nil)
	}
	r := new(Sample)
	r.LocationsStartIndex = m.LocationsStartIndex
	r.LocationsLength = m.LocationsLength
	if rhs := m.Value; rhs != nil {
		tmpContainer := make([]int64, len(rhs))
		copy(tmpContainer, rhs)
		r.Value = tmpContainer
	}
	if rhs := m.AttributeIndices; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.AttributeIndices = tmpContainer
	}
	if rhs := m.LinkIndex; rhs != nil {
		tmpVal := *rhs
		r.LinkIndex = &tmpVal
	}
	if rhs := m.TimestampsUnixNano; rhs != nil {
		tmpContainer := make([]uint64, len(rhs))
		copy(tmpContainer, rhs)
		r.TimestampsUnixNano = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Sample) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Mapping) CloneVT() *Mapping {
	if m == nil {
		return (*Mapping)(nil)
	}
	r := new(Mapping)
	r.MemoryStart = m.MemoryStart
	r.MemoryLimit = m.MemoryLimit
	r.FileOffset = m.FileOffset
	r.FilenameStrindex = m.FilenameStrindex
	r.HasFunctions = m.HasFunctions
	r.HasFilenames = m.HasFilenames
	r.HasLineNumbers = m.HasLineNumbers
	r.HasInlineFrames = m.HasInlineFrames
	if rhs := m.AttributeIndices; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.AttributeIndices = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Mapping) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Location) CloneVT() *Location {
	if m == nil {
		return (*Location)(nil)
	}
	r := new(Location)
	r.Address = m.Address
	r.IsFolded = m.IsFolded
	if rhs := m.MappingIndex; rhs != nil {
		tmpVal := *rhs
		r.MappingIndex = &tmpVal
	}
	if rhs := m.Line; rhs != nil {
		tmpContainer := make([]*Line, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = v.CloneVT()
		}
		r.Line = tmpContainer
	}
	if rhs := m.AttributeIndices; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.AttributeIndices = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Location) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Line) CloneVT() *Line {
	if m == nil {
		return (*Line)(nil)
	}
	r := new(Line)
	r.FunctionIndex = m.FunctionIndex
	r.Line = m.Line
	r.Column = m.Column
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Line) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Function) CloneVT() *Function {
	if m == nil {
		return (*Function)(nil)
	}
	r := new(Function)
	r.NameStrindex = m.NameStrindex
	r.SystemNameStrindex = m.SystemNameStrindex
	r.FilenameStrindex = m.FilenameStrindex
	r.StartLine = m.StartLine
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Function) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *ProfilesData) EqualVT(that *ProfilesData) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.ResourceProfiles) != len(that.ResourceProfiles) {
		return false
	}
	for i, vx := range this.ResourceProfiles {
		vy := that.ResourceProfiles[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ResourceProfiles{}
			}
			if q == nil {
				q = &ResourceProfiles{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ProfilesData) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ProfilesData)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ResourceProfiles) EqualVT(that *ResourceProfiles) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Resource.EqualVT(that.Resource) {
		return false
	}
	if len(this.ScopeProfiles) != len(that.ScopeProfiles) {
		return false
	}
	for i, vx := range this.ScopeProfiles {
		vy := that.ScopeProfiles[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ScopeProfiles{}
			}
			if q == nil {
				q = &ScopeProfiles{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.SchemaUrl != that.SchemaUrl {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ResourceProfiles) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ResourceProfiles)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ScopeProfiles) EqualVT(that *ScopeProfiles) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if !this.Scope.EqualVT(that.Scope) {
		return false
	}
	if len(this.Profiles) != len(that.Profiles) {
		return false
	}
	for i, vx := range this.Profiles {
		vy := that.Profiles[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Profile{}
			}
			if q == nil {
				q = &Profile{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.SchemaUrl != that.SchemaUrl {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ScopeProfiles) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ScopeProfiles)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Profile) EqualVT(that *Profile) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.SampleType) != len(that.SampleType) {
		return false
	}
	for i, vx := range this.SampleType {
		vy := that.SampleType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &ValueType{}
			}
			if q == nil {
				q = &ValueType{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Sample) != len(that.Sample) {
		return false
	}
	for i, vx := range this.Sample {
		vy := that.Sample[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Sample{}
			}
			if q == nil {
				q = &Sample{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.MappingTable) != len(that.MappingTable) {
		return false
	}
	for i, vx := range this.MappingTable {
		vy := that.MappingTable[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Mapping{}
			}
			if q == nil {
				q = &Mapping{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.LocationTable) != len(that.LocationTable) {
		return false
	}
	for i, vx := range this.LocationTable {
		vy := that.LocationTable[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Location{}
			}
			if q == nil {
				q = &Location{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.LocationIndices) != len(that.LocationIndices) {
		return false
	}
	for i, vx := range this.LocationIndices {
		vy := that.LocationIndices[i]
		if vx != vy {
			return false
		}
	}
	if len(this.FunctionTable) != len(that.FunctionTable) {
		return false
	}
	for i, vx := range this.FunctionTable {
		vy := that.FunctionTable[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Function{}
			}
			if q == nil {
				q = &Function{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.AttributeTable) != len(that.AttributeTable) {
		return false
	}
	for i, vx := range this.AttributeTable {
		vy := that.AttributeTable[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &v11.KeyValue{}
			}
			if q == nil {
				q = &v11.KeyValue{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.AttributeUnits) != len(that.AttributeUnits) {
		return false
	}
	for i, vx := range this.AttributeUnits {
		vy := that.AttributeUnits[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &AttributeUnit{}
			}
			if q == nil {
				q = &AttributeUnit{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.LinkTable) != len(that.LinkTable) {
		return false
	}
	for i, vx := range this.LinkTable {
		vy := that.LinkTable[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Link{}
			}
			if q == nil {
				q = &Link{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.StringTable) != len(that.StringTable) {
		return false
	}
	for i, vx := range this.StringTable {
		vy := that.StringTable[i]
		if vx != vy {
			return false
		}
	}
	if this.TimeNanos != that.TimeNanos {
		return false
	}
	if this.DurationNanos != that.DurationNanos {
		return false
	}
	if !this.PeriodType.EqualVT(that.PeriodType) {
		return false
	}
	if this.Period != that.Period {
		return false
	}
	if len(this.CommentStrindices) != len(that.CommentStrindices) {
		return false
	}
	for i, vx := range this.CommentStrindices {
		vy := that.CommentStrindices[i]
		if vx != vy {
			return false
		}
	}
	if this.DefaultSampleTypeStrindex != that.DefaultSampleTypeStrindex {
		return false
	}
	if string(this.ProfileId) != string(that.ProfileId) {
		return false
	}
	if len(this.Attributes) != len(that.Attributes) {
		return false
	}
	for i, vx := range this.Attributes {
		vy := that.Attributes[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &v11.KeyValue{}
			}
			if q == nil {
				q = &v11.KeyValue{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.DroppedAttributesCount != that.DroppedAttributesCount {
		return false
	}
	if this.OriginalPayloadFormat != that.OriginalPayloadFormat {
		return false
	}
	if string(this.OriginalPayload) != string(that.OriginalPayload) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Profile) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Profile)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *AttributeUnit) EqualVT(that *AttributeUnit) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.AttributeKeyStrindex != that.AttributeKeyStrindex {
		return false
	}
	if this.UnitStrindex != that.UnitStrindex {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *AttributeUnit) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*AttributeUnit)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Link) EqualVT(that *Link) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.TraceId) != string(that.TraceId) {
		return false
	}
	if string(this.SpanId) != string(that.SpanId) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Link) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Link)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *ValueType) EqualVT(that *ValueType) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.TypeStrindex != that.TypeStrindex {
		return false
	}
	if this.UnitStrindex != that.UnitStrindex {
		return false
	}
	if this.AggregationTemporality != that.AggregationTemporality {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *ValueType) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*ValueType)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Sample) EqualVT(that *Sample) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.LocationsStartIndex != that.LocationsStartIndex {
		return false
	}
	if this.LocationsLength != that.LocationsLength {
		return false
	}
	if len(this.Value) != len(that.Value) {
		return false
	}
	for i, vx := range this.Value {
		vy := that.Value[i]
		if vx != vy {
			return false
		}
	}
	if len(this.AttributeIndices) != len(that.AttributeIndices) {
		return false
	}
	for i, vx := range this.AttributeIndices {
		vy := that.AttributeIndices[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.LinkIndex, that.LinkIndex; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.TimestampsUnixNano) != len(that.TimestampsUnixNano) {
		return false
	}
	for i, vx := range this.TimestampsUnixNano {
		vy := that.TimestampsUnixNano[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Sample) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Sample)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Mapping) EqualVT(that *Mapping) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.MemoryStart != that.MemoryStart {
		return false
	}
	if this.MemoryLimit != that.MemoryLimit {
		return false
	}
	if this.FileOffset != that.FileOffset {
		return false
	}
	if this.FilenameStrindex != that.FilenameStrindex {
		return false
	}
	if len(this.AttributeIndices) != len(that.AttributeIndices) {
		return false
	}
	for i, vx := range this.AttributeIndices {
		vy := that.AttributeIndices[i]
		if vx != vy {
			return false
		}
	}
	if this.HasFunctions != that.HasFunctions {
		return false
	}
	if this.HasFilenames != that.HasFilenames {
		return false
	}
	if this.HasLineNumbers != that.HasLineNumbers {
		return false
	}
	if this.HasInlineFrames != that.HasInlineFrames {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Mapping) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Mapping)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Location) EqualVT(that *Location) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.MappingIndex, that.MappingIndex; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if this.Address != that.Address {
		return false
	}
	if len(this.Line) != len(that.Line) {
		return false
	}
	for i, vx := range this.Line {
		vy := that.Line[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &Line{}
			}
			if q == nil {
				q = &Line{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if this.IsFolded != that.IsFolded {
		return false
	}
	if len(this.AttributeIndices) != len(that.AttributeIndices) {
		return false
	}
	for i, vx := range this.AttributeIndices {
		vy := that.AttributeIndices[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Location) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Location)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Line) EqualVT(that *Line) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.FunctionIndex != that.FunctionIndex {
		return false
	}
	if this.Line != that.Line {
		return false
	}
	if this.Column != that.Column {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Line) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Line)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Function) EqualVT(that *Function) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.NameStrindex != that.NameStrindex {
		return false
	}
	if this.SystemNameStrindex != that.SystemNameStrindex {
		return false
	}
	if this.FilenameStrindex != that.FilenameStrindex {
		return false
	}
	if this.StartLine != that.StartLine {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Function) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Function)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (m *ProfilesData) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProfilesData) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ProfilesData) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.ResourceProfiles) > 0 {
		for iNdEx := len(m.ResourceProfiles) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ResourceProfiles[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceProfiles) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceProfiles) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ResourceProfiles) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.SchemaUrl) > 0 {
		i -= len(m.SchemaUrl)
		copy(dAtA[i:], m.SchemaUrl)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.SchemaUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeProfiles) > 0 {
		for iNdEx := len(m.ScopeProfiles) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.ScopeProfiles[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Resource != nil {
		size, err := m.Resource.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopeProfiles) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeProfiles) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ScopeProfiles) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.SchemaUrl) > 0 {
		i -= len(m.SchemaUrl)
		copy(dAtA[i:], m.SchemaUrl)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.SchemaUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Profiles) > 0 {
		for iNdEx := len(m.Profiles) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Profiles[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Scope != nil {
		size, err := m.Scope.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Profile) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Profile) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.OriginalPayload) > 0 {
		i -= len(m.OriginalPayload)
		copy(dAtA[i:], m.OriginalPayload)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.OriginalPayload)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.OriginalPayloadFormat) > 0 {
		i -= len(m.OriginalPayloadFormat)
		copy(dAtA[i:], m.OriginalPayloadFormat)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.OriginalPayloadFormat)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DroppedAttributesCount != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.DroppedAttributesCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Attributes[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.ProfileId) > 0 {
		i -= len(m.ProfileId)
		copy(dAtA[i:], m.ProfileId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ProfileId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.DefaultSampleTypeStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.DefaultSampleTypeStrindex))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.CommentStrindices) > 0 {
		var pksize2 int
		for _, num := range m.CommentStrindices {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.CommentStrindices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x7a
	}
	if m.Period != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x70
	}
	if m.PeriodType != nil {
		size, err := m.PeriodType.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x6a
	}
	if m.DurationNanos != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.DurationNanos))
		i--
		dAtA[i] = 0x60
	}
	if m.TimeNanos != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TimeNanos))
		i--
		dAtA[i] = 0x58
	}
	if len(m.StringTable) > 0 {
		for iNdEx := len(m.StringTable) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StringTable[iNdEx])
			copy(dAtA[i:], m.StringTable[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.StringTable[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.LinkTable) > 0 {
		for iNdEx := len(m.LinkTable) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.LinkTable[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.AttributeUnits) > 0 {
		for iNdEx := len(m.AttributeUnits) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.AttributeUnits[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AttributeTable) > 0 {
		for iNdEx := len(m.AttributeTable) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.AttributeTable[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.FunctionTable) > 0 {
		for iNdEx := len(m.FunctionTable) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.FunctionTable[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.LocationIndices) > 0 {
		var pksize4 int
		for _, num := range m.LocationIndices {
			pksize4 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize4
		j3 := i
		for _, num1 := range m.LocationIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA[j3] = uint8(num)
			j3++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize4))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LocationTable) > 0 {
		for iNdEx := len(m.LocationTable) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.LocationTable[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MappingTable) > 0 {
		for iNdEx := len(m.MappingTable) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.MappingTable[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Sample) > 0 {
		for iNdEx := len(m.Sample) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Sample[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SampleType) > 0 {
		for iNdEx := len(m.SampleType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.SampleType[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttributeUnit) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttributeUnit) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *AttributeUnit) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.UnitStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.UnitStrindex))
		i--
		dAtA[i] = 0x10
	}
	if m.AttributeKeyStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.AttributeKeyStrindex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Link) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Link) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.SpanId) > 0 {
		i -= len(m.SpanId)
		copy(dAtA[i:], m.SpanId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.SpanId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValueType) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValueType) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *ValueType) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.AggregationTemporality != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.AggregationTemporality))
		i--
		dAtA[i] = 0x18
	}
	if m.UnitStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.UnitStrindex))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TypeStrindex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sample) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sample) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Sample) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.TimestampsUnixNano) > 0 {
		var pksize2 int
		for _, num := range m.TimestampsUnixNano {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num := range m.TimestampsUnixNano {
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x32
	}
	if m.LinkIndex != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.LinkIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AttributeIndices) > 0 {
		var pksize4 int
		for _, num := range m.AttributeIndices {
			pksize4 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize4
		j3 := i
		for _, num1 := range m.AttributeIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA[j3] = uint8(num)
			j3++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize4))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		var pksize6 int
		for _, num := range m.Value {
			pksize6 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize6
		j5 := i
		for _, num1 := range m.Value {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA[j5] = uint8(num)
			j5++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize6))
		i--
		dAtA[i] = 0x1a
	}
	if m.LocationsLength != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.LocationsLength))
		i--
		dAtA[i] = 0x10
	}
	if m.LocationsStartIndex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.LocationsStartIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Mapping) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mapping) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Mapping) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.HasInlineFrames {
		i--
		if m.HasInlineFrames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.HasLineNumbers {
		i--
		if m.HasLineNumbers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.HasFilenames {
		i--
		if m.HasFilenames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.HasFunctions {
		i--
		if m.HasFunctions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.AttributeIndices) > 0 {
		var pksize2 int
		for _, num := range m.AttributeIndices {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.AttributeIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x2a
	}
	if m.FilenameStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.FilenameStrindex))
		i--
		dAtA[i] = 0x20
	}
	if m.FileOffset != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.FileOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryLimit != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.MemoryLimit))
		i--
		dAtA[i] = 0x10
	}
	if m.MemoryStart != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.MemoryStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Location) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.AttributeIndices) > 0 {
		var pksize2 int
		for _, num := range m.AttributeIndices {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.AttributeIndices {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsFolded {
		i--
		if m.IsFolded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Line) > 0 {
		for iNdEx := len(m.Line) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Line[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Address != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Address))
		i--
		dAtA[i] = 0x10
	}
	if m.MappingIndex != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.MappingIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Line) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Line) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Line) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Column != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x18
	}
	if m.Line != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x10
	}
	if m.FunctionIndex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.FunctionIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Function) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Function) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.StartLine != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.StartLine))
		i--
		dAtA[i] = 0x20
	}
	if m.FilenameStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.FilenameStrindex))
		i--
		dAtA[i] = 0x18
	}
	if m.SystemNameStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.SystemNameStrindex))
		i--
		dAtA[i] = 0x10
	}
	if m.NameStrindex != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.NameStrindex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProfilesData) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceProfiles) > 0 {
		for _, e := range m.ResourceProfiles {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *ResourceProfiles) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.ScopeProfiles) > 0 {
		for _, e := range m.ScopeProfiles {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.SchemaUrl)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ScopeProfiles) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scope != nil {
		l = m.Scope.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Profiles) > 0 {
		for _, e := range m.Profiles {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.SchemaUrl)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Profile) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SampleType) > 0 {
		for _, e := range m.SampleType {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.Sample) > 0 {
		for _, e := range m.Sample {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.MappingTable) > 0 {
		for _, e := range m.MappingTable {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.LocationTable) > 0 {
		for _, e := range m.LocationTable {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.LocationIndices) > 0 {
		l = 0
		for _, e := range m.LocationIndices {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if len(m.FunctionTable) > 0 {
		for _, e := range m.FunctionTable {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.AttributeTable) > 0 {
		for _, e := range m.AttributeTable {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.AttributeUnits) > 0 {
		for _, e := range m.AttributeUnits {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.LinkTable) > 0 {
		for _, e := range m.LinkTable {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.StringTable) > 0 {
		for _, s := range m.StringTable {
			l = len(s)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.TimeNanos != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TimeNanos))
	}
	if m.DurationNanos != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.DurationNanos))
	}
	if m.PeriodType != nil {
		l = m.PeriodType.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Period != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Period))
	}
	if len(m.CommentStrindices) > 0 {
		l = 0
		for _, e := range m.CommentStrindices {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if m.DefaultSampleTypeStrindex != 0 {
		n += 2 + protobuf_go_lite.SizeOfVarint(uint64(m.DefaultSampleTypeStrindex))
	}
	l = len(m.ProfileId)
	if l > 0 {
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.SizeVT()
			n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.DroppedAttributesCount != 0 {
		n += 2 + protobuf_go_lite.SizeOfVarint(uint64(m.DroppedAttributesCount))
	}
	l = len(m.OriginalPayloadFormat)
	if l > 0 {
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.OriginalPayload)
	if l > 0 {
		n += 2 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *AttributeUnit) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttributeKeyStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.AttributeKeyStrindex))
	}
	if m.UnitStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.UnitStrindex))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Link) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.SpanId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ValueType) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TypeStrindex))
	}
	if m.UnitStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.UnitStrindex))
	}
	if m.AggregationTemporality != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.AggregationTemporality))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Sample) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocationsStartIndex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.LocationsStartIndex))
	}
	if m.LocationsLength != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.LocationsLength))
	}
	if len(m.Value) > 0 {
		l = 0
		for _, e := range m.Value {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if len(m.AttributeIndices) > 0 {
		l = 0
		for _, e := range m.AttributeIndices {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if m.LinkIndex != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.LinkIndex))
	}
	if len(m.TimestampsUnixNano) > 0 {
		l = 0
		for _, e := range m.TimestampsUnixNano {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	n += len(m.unknownFields)
	return n
}

func (m *Mapping) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemoryStart != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.MemoryStart))
	}
	if m.MemoryLimit != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.MemoryLimit))
	}
	if m.FileOffset != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.FileOffset))
	}
	if m.FilenameStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.FilenameStrindex))
	}
	if len(m.AttributeIndices) > 0 {
		l = 0
		for _, e := range m.AttributeIndices {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if m.HasFunctions {
		n += 2
	}
	if m.HasFilenames {
		n += 2
	}
	if m.HasLineNumbers {
		n += 2
	}
	if m.HasInlineFrames {
		n += 2
	}
	n += len(m.unknownFields)
	return n
}

func (m *Location) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MappingIndex != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.MappingIndex))
	}
	if m.Address != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Address))
	}
	if len(m.Line) > 0 {
		for _, e := range m.Line {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.IsFolded {
		n += 2
	}
	if len(m.AttributeIndices) > 0 {
		l = 0
		for _, e := range m.AttributeIndices {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	n += len(m.unknownFields)
	return n
}

func (m *Line) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FunctionIndex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.FunctionIndex))
	}
	if m.Line != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Line))
	}
	if m.Column != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Column))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Function) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.NameStrindex))
	}
	if m.SystemNameStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.SystemNameStrindex))
	}
	if m.FilenameStrindex != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.FilenameStrindex))
	}
	if m.StartLine != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.StartLine))
	}
	n += len(m.unknownFields)
	return n
}

func (m *ProfilesData) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProfilesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProfilesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceProfiles = append(m.ResourceProfiles, &ResourceProfiles{})
			if err := m.ResourceProfiles[len(m.ResourceProfiles)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceProfiles) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceProfiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceProfiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &v1.Resource{}
			}
			if err := m.Resource.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeProfiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeProfiles = append(m.ScopeProfiles, &ScopeProfiles{})
			if err := m.ScopeProfiles[len(m.ScopeProfiles)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeProfiles) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeProfiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeProfiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &v11.InstrumentationScope{}
			}
			if err := m.Scope.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Profiles = append(m.Profiles, &Profile{})
			if err := m.Profiles[len(m.Profiles)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SampleType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SampleType = append(m.SampleType, &ValueType{})
			if err := m.SampleType[len(m.SampleType)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sample = append(m.Sample, &Sample{})
			if err := m.Sample[len(m.Sample)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MappingTable = append(m.MappingTable, &Mapping{})
			if err := m.MappingTable[len(m.MappingTable)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationTable = append(m.LocationTable, &Location{})
			if err := m.LocationTable[len(m.LocationTable)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LocationIndices = append(m.LocationIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LocationIndices) == 0 {
					m.LocationIndices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LocationIndices = append(m.LocationIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationIndices", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionTable = append(m.FunctionTable, &Function{})
			if err := m.FunctionTable[len(m.FunctionTable)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeTable = append(m.AttributeTable, &v11.KeyValue{})
			if err := m.AttributeTable[len(m.AttributeTable)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributeUnits = append(m.AttributeUnits, &AttributeUnit{})
			if err := m.AttributeUnits[len(m.AttributeUnits)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkTable = append(m.LinkTable, &Link{})
			if err := m.LinkTable[len(m.LinkTable)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringTable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringTable = append(m.StringTable, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNanos", wireType)
			}
			m.TimeNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanos", wireType)
			}
			m.DurationNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeriodType == nil {
				m.PeriodType = &ValueType{}
			}
			if err := m.PeriodType.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CommentStrindices = append(m.CommentStrindices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CommentStrindices) == 0 {
					m.CommentStrindices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CommentStrindices = append(m.CommentStrindices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentStrindices", wireType)
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSampleTypeStrindex", wireType)
			}
			m.DefaultSampleTypeStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultSampleTypeStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = append(m.ProfileId[:0], dAtA[iNdEx:postIndex]...)
			if m.ProfileId == nil {
				m.ProfileId = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &v11.KeyValue{})
			if err := m.Attributes[len(m.Attributes)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DroppedAttributesCount", wireType)
			}
			m.DroppedAttributesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DroppedAttributesCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPayloadFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalPayloadFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalPayload = append(m.OriginalPayload[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalPayload == nil {
				m.OriginalPayload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttributeUnit) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttributeUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttributeUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeKeyStrindex", wireType)
			}
			m.AttributeKeyStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributeKeyStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitStrindex", wireType)
			}
			m.UnitStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = append(m.TraceId[:0], dAtA[iNdEx:postIndex]...)
			if m.TraceId == nil {
				m.TraceId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpanId = append(m.SpanId[:0], dAtA[iNdEx:postIndex]...)
			if m.SpanId == nil {
				m.SpanId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValueType) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValueType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValueType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeStrindex", wireType)
			}
			m.TypeStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitStrindex", wireType)
			}
			m.UnitStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationTemporality", wireType)
			}
			m.AggregationTemporality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationTemporality |= AggregationTemporality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sample) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sample: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sample: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationsStartIndex", wireType)
			}
			m.LocationsStartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationsStartIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationsLength", wireType)
			}
			m.LocationsLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocationsLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Value = append(m.Value, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Value) == 0 {
					m.Value = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Value = append(m.Value, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeIndices = append(m.AttributeIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeIndices) == 0 {
					m.AttributeIndices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeIndices = append(m.AttributeIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeIndices", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LinkIndex = &v
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TimestampsUnixNano = append(m.TimestampsUnixNano, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TimestampsUnixNano) == 0 {
					m.TimestampsUnixNano = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TimestampsUnixNano = append(m.TimestampsUnixNano, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampsUnixNano", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mapping) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStart", wireType)
			}
			m.MemoryStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryStart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileOffset", wireType)
			}
			m.FileOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilenameStrindex", wireType)
			}
			m.FilenameStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilenameStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeIndices = append(m.AttributeIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeIndices) == 0 {
					m.AttributeIndices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeIndices = append(m.AttributeIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeIndices", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFunctions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFunctions = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFilenames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFilenames = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLineNumbers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasLineNumbers = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasInlineFrames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasInlineFrames = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MappingIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MappingIndex = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Line = append(m.Line, &Line{})
			if err := m.Line[len(m.Line)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFolded = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AttributeIndices = append(m.AttributeIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protobuf_go_lite.ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AttributeIndices) == 0 {
					m.AttributeIndices = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return protobuf_go_lite.ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AttributeIndices = append(m.AttributeIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Line) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Line: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Line: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionIndex", wireType)
			}
			m.FunctionIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FunctionIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameStrindex", wireType)
			}
			m.NameStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NameStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemNameStrindex", wireType)
			}
			m.SystemNameStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemNameStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilenameStrindex", wireType)
			}
			m.FilenameStrindex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilenameStrindex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartLine |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
